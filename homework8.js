// После простомтра всех примеров понял, что мало что понял. Еще многое нужно разобрать и освоить, 
// так ка учусь с нуля и пока все дается крайне не просто. Прокомментирую как смогу и как понял из описания в интернете.

if (!("a" in window)) {
    var a = 1;
}
alert(a);
/* 
Все глобальные переменные являются свойствами окна. Запись var a = 1 функционально эквивалентна записи window.a = 1.
Все объявления переменных поднимаются в верхнюю часть содержащей их области.
Хотя объявления переменных поднимаются, инициализация переменных - нет. Эта строка является одновременно объявлением и инициализацией:
var a = 1;
Когда движки JavaScript сталкиваются с комбинацией объявления и инициализации, он выполняет это разделение автоматически, чтобы объявление можно было поднять.
Инициализация не поднимается, потому что это может повлиять на значение переменной во время выполнения кода.
Исходя из всего выше сказанного наш пример читается так:
Сначала объявляется переменная a, а затем оператор if говорит: «Если a не объявлено, инициализируйте a, чтобы он имел значение 1.» 
Конечно, это условие никогда не может быть истинным, поэтому для переменной a остается значение по умолчанию undefined.

*/

var b = function a(x) {
    x && a(--x);
};
alert(a);
/*
Алерт выведет undefinded, так как возмет значение а из первого примера.
Этот пример основан на знании трех ключевых аспектов JavaScript:
1)Это концепция подъема объявления переменных, на которую также опирался пример №1.
2)Это подъем объявления функции. Все объявления функций поднимаются в верхнюю часть области действия вместе с объявлениями переменных:
    Объявление функции выглядит так:
    function functionName(arg1, arg2){
    //function body
    }
    Это противоположно выражению функции, которое является присваиванием переменной:
    var functionName = function(arg1, arg2){
    //function body
    };
Выражения функций не поднимаются.
3)Объявления функций переопределяют объявления переменных, но не инициализации переменных.
Функция на самом деле является выражением функции, несмотря на название. Именованные выражения функций не считаются объявлениями функций и, следовательно, не переопределяются объявлениями переменных.
*/

function a(x) {
    return x * 2;
}
var a;
alert(a);

/*
После того как детально разобрали предыдущий пример, с этим не должно возникнуть проблем.
Нужно понять, что объявления функций важнее объявлений переменных, если нет инициализации. Здесь нет инициализации, поэтому в предупреждении отображается исходный код функции.
*/

function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);

/*
С точки зрения теории, для меня это оказался самый сложный пример, я так до конца и не понял, но нашел объяснение, которое слегка прояснила его.

Ответ - 10 во всех браузерах. Нужно знать только одну концепцию, чтобы разобраться в этом коде.
ECMA-262, 3-е издание, раздел 10.1.8 говорит об объекте arguments:
        Для каждого неотрицательного целого числа arg, меньшего значения свойства length, создается свойство с именем ToString (arg) и атрибутами свойства {DontEnum}. 
        Начальным значением этого свойства является значение соответствующего фактического параметра, предоставленного вызывающей стороной. 
        Первое фактическое значение параметра соответствует arg = 0, второе - arg = 1 и так далее. В случае, когда arg меньше количества формальных параметров для объекта Function, 
        это свойство разделяет свое значение с соответствующим свойством объекта активации. Это означает, что изменение этого свойства изменяет соответствующее свойство объекта активации и наоборот.

Короче говоря, каждая запись в объекте arguments является дубликатом каждого именованного аргумента. 
Обратите внимание, что используются общие значения, но не пространство памяти. 
Два пространства памяти синхронизируются движком JavaScript, что означает, что оба аргумента [2] и a всегда содержат одно и то же значение. В итоге это значение равно 10.
*/

function a() {
    alert(this);
}
a.call(null);

/*
Данный пример вообще не понял, даже после того как нашел его разбор и перечитал несколько раз, прилагаю данный разбор к решению:

Во-первых, надо понять, как определяется значение этого объекта. Когда метод вызывается для объекта, это указывает на объект, на котором находится метод. Пример:

var object = {
    method: function() {
        alert(this === object);    //true
    }
}
object.method();

В этом коде это заканчивается указанием на объект при вызове object.method (). В глобальной области это эквивалентно окну (в браузерах, в средах, отличных от браузера, это эквивалент глобального объекта),
поэтому это также равно окну внутри функции, которая не является свойством объекта. Пример:

function method() {
    alert(this === window);    //true
}
method();

Здесь это заканчивается указанием на глобальный объект window.

Вооружившись этими знаниями,  теперь можно заняться второй важной концепцией: что делает call (). Метод call () выполняет функцию, как если бы это был метод другого объекта.
Первый аргумент становится this внутри метода, а каждый последующий аргумент передается в качестве аргумента функции. Учитываем следующее:

function method() {
    alert(this === window);
}
method();    //true
method.call(document);   //false

Здесь вызывается функция method (), и это будет документ. Следовательно, в предупреждении отображается «ложь».

Интересная часть ECMA-262, 3-е издание описывает, что должно произойти, если null передается в качестве первого аргумента call ():

Если thisArg имеет значение null или undefined, вызываемой функции передается глобальный объект как значение this. В противном случае вызываемой функции передается ToObject (thisArg) как значение this.

Таким образом, всякий раз, когда null передается в call () (или его родственнику, apply ()), по умолчанию используется глобальный объект, которым является window.
Учитывая это, пример кода можно переписать более понятным способом как:

function a() {
    alert(this);
}
a.call(window);

Этот код делает очевидным, что предупреждение будет отображать строковый эквивалент объекта окна.
*/




